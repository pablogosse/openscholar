<?php
// $Id$

include_once 'os_events.features.inc';

/**
 * Implements hook_os_app_info().
 */
function os_events_os_app_info() {
  $apps = array();

  $apps['os_events'] = array(
    'path' => 'calendar',
    'nodetypes' => array(
      'event',
    ),
    'views tabs' => array(
      'os_events' => array(
        'page_1' => array('calendar'), // Month display
        'page_2' => array('calendar'), // Week display
        'page_3' => array('calendar'), // Year display
        'page_4', // Upcoming
        'feed_1', // iCal
        'feed_2', // rss
      ),
    ),
    'importers' => array(
      'event' => array(
        'ical' => 'os_ical',
        'csv' => 'os_events_csv',
      ),
    ),
    'browse_pages' => array(
      'event' => array(
        'url' => 'browse/events',
        'title' => t('Events'),
        'display_mode' => 'teaser',
        'menu_item' => 'events',
      ),
    ),
  );

  return $apps;
}

/**
 * Implements hook_theme().
 */
function os_events_theme() {
  return array(
    'os_events_export_links' => array(
      'variables' => array(
        'register' => NULL,
        'ical' => NULL,
        'subscribe' => NULL,
      ),
      'template' => 'os-events-export-links',
      'path' => drupal_get_path('module', 'os_events') . '/template',
    ),
  );
}

/**
 * Implements hook_menu().
 */
function os_events_menu() {
  $items = array();

  $items['os_events/%ctools_js/registration/%node'] = array(
    'title callback' => 'os_events_register_form_title',
    'title arguments' => array('node', 3),
    'page callback' => 'os_events_events_register',
    'page arguments' => array(1, 3),
    'access arguments' => array('create event_signup_simple registration'),
  );

  $items['node/%node/registrations/export/%'] = $items['node/%node/registrations/export'] = array(
    'title' => 'Export attendees to csv',
    'access callback' => 'registration_administer_registrations_access',
    'access arguments' => array(0, 1),
    'page arguments' => array(1),
    'page callback' => 'os_events_export_to_csv',
  );

  return $items;
}

/**
 * Implements hook_entity_view_alter().
 */
function os_events_entity_view_alter(&$build, $type) {
  // Removing extra fields from event registration page in full view mode.
  if ($type == 'registration' && $build['#view_mode'] == 'full' && $build['#bundle'] == 'event_signup_simple') {
    $param = drupal_get_query_parameters();
    $node = node_load($build['#entity']->entity_id);

    // Overriding Event entity link display.
    $build['host_entity_link']['#label'] = t('Event');
    $build['host_entity_link']['#items'][0]['#markup'] = isset($build['host_entity_link']['#items'][0]['#markup']) ? l($node->title, 'node/' . $build['#entity']->entity_id, array('query' => $param)) : NULL;
    $build['host_entity_link']['#weight'] = -20;
    $entity_link_tmp = $build['host_entity_link'];
    unset($build['host_entity_link']);
    $build['entity_link'] = $entity_link_tmp;

    // Overriding Created date display.
    $build['created']['#weight'] = -9;
    $created_tmp = $build['created'];
    unset($build['created']);
    $build['created'] = $created_tmp;

    // Reset additional fields display.
    unset($build['spaces']);
    unset($build['author']);
    unset($build['state']);
  }
}

/**
 * Page callback; Exports event's registrants.
 */
function os_events_export_to_csv($node, $delta = FALSE) {
  if (!module_exists('os_exporter')) {
    return;
  }

  $exporter = os_exporter_get_exporter_handler('csv');
  $exporter->setFileHeader(array(t('Email'), t('Created Time'), t('Department'), t('Full name')));

  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'registration')
    ->propertyCondition('entity_id', $node->nid)
    ->propertyCondition('entity_type', 'node');

  if ($delta !== FALSE && isset($node->field_date['und'][$delta])) {
    $date = $node->field_date['und'][$delta]['value'];
    $query->fieldCondition('field_repeating_event_date', 'value', $date);
  }

  $result = $query->execute();

  if (empty($result['registration'])) {
    return;
  }

  $attendees = entity_load('registration', array_keys($result['registration']));

  foreach ($attendees as $attendee) {
    $wrapper = entity_metadata_wrapper('registration', $attendee);

    $exporter->addContent(array(
      $attendee->anon_mail,
      '"' . format_date($attendee->created) . '"',
      $wrapper->field_department->value(),
      $wrapper->field_full_name->value(),
    ));
  }

  $exporter->exportToFile($node->title . '-' . (isset($date)?$date . '-':'') .'attendees.csv');

  return $node->title;
}

/**
 * Check the capacity if the event reach it's capacity.
 *
 * @param $node
 *  The event to check capacity for.
 * @return bool
 *  Returns TRUE if user has registration access and capacity hasn't been reached
 *  or if the event has unlimited capacity. Otherwise, return FALSE.
 */
function os_events_event_registration_reach_capacity($node, $date = '') {
  // Check how much registration exists for this event.
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'registration')
    ->propertyCondition('entity_id', $node->nid)
    ->propertyCondition('entity_type', 'node');

  // Get all registrations unless we specify a date to check.
  if ($date) {
    $query->fieldCondition('field_repeating_event_date', 'value', $date);
  }

  $registrations_number = $query->count()->execute();

  // Get the settings of the registration for this event.
  $settings = os_events_registration_repeating_entity_settings('node', $node->nid, $date);

  if (!$settings['status']) {
    return FALSE;
  }

  // When the capacity set to 0 the registration number is unlimited. When not,
  // check if the registration number didn't pass the capacity number.
  if ($settings['capacity'] == 0 xor $registrations_number < $settings['capacity']) {
    return user_access('create event_signup_simple registration');
  }
  else {
    return FALSE;
  }
}

/**
 * Title callback for the event registration menu item.
 *  The entity type.
 *
 * @param $entity_type
 *  The entity type.
 * @param $entity_id
 *  The entity ID.
 *
 * @return string
 *  The title of the menu item.
 */
function os_events_register_form_title($entity_type, $entity_id) {
  $wrapper = entity_metadata_Wrapper($entity_type, $entity_id);
  return t('Register to @title', array('@title' => $wrapper->label()));
}

/**
 * Implements hook_admin_paths().
 */
function os_events_admin_paths() {
  return array(
    'os_events/registration/*' => TRUE,
  );
}

/**
 * Implements hook_os_entity_view_modes()
 */
function os_events_os_entity_view_modes() {
  return array('node' =>
    array('event' => array('sidebar_teaser')
  ));
}

/**
 * hook os_widget
 *
 * Events blocks that can be used on an OpenScholar site
 */
function os_events_os_widget() {
  $items = array();

  //Mini calendar that displays events by month
  $items['views-os_events-block_1'] = array(
    'module' => 'views',
    'delta' => 'os_events-block_1',
    'region' => 'sidebar_second',
    'weight' => '-10',
    'info' => t('Mini Calendar'),
  );

  return $items;
}

// TODO: Remove when os_layout_get is refactored to handle widget titles better
function os_events_os_widget_alter(&$widget) {
  if ($widget['delta'] == 'os_events-block_1') {
    $widget['info'] = t('Mini Calendar');
  }
}

/**
 * Implements hook_vsite_og_node_type_info().
 */
function os_events_vsite_og_node_type_info() {
  return array(
    'event' => 'group content',
  );
}

/**
 * Implements hook_default_registration_type().
 */
function os_events_default_registration_type() {
  $items = array();
  $items['event_signup_simple'] = entity_import('registration_type', '{
    "name" : "event_signup_simple",
    "label" : "Event signup",
    "locked" : "0",
    "weight" : "0",
    "data" : null,
    "rdf_mapping" : []
  }');
  return $items;
}

/**
 * Implements hook_views_pre_render().
 */
function os_events_views_pre_render(&$view) {
  if ($view->name != 'os_events') {
    return;
  }

  // Not a page display.
  if (strpos($view->current_display, 'page') !== 0) {
    return;
  }

  if (empty($view->attachment_before)) {
    return;
  }

  // only display subscribe links if listing is the events landing page or a list of upcoming events 
  // and if it is set to be displayed as per cp/settings page checkbox
  if (!variable_get('os_exporter_disable_event_export', 0) && ((isset($view->exposed_input['month']) && $view->exposed_input['month'] == date('Y-m')) || strpos($view->get_path(), "calendar/upcoming") !== FALSE)) {
    $view->attachment_before = '<a title="Note: Past events are not included" class="cal-export">' . t('Export') . '</a>' . $view->attachment_before;
  }
}

function os_events_date_formatter_pre_view_alter(&$entity, $vars) {
  if ($entity->type != 'event') {
    return;
  }

  if (!isset($entity->date_id)) {
       // The current view rendering this entity. We try and set it if it is not already set.
    if ((isset($entity->view) || $entity->view = views_get_current_view())
      && isset($entity->view->row_index)
      && isset($entity->view->result[$entity->view->row_index])) {

      // This entity is being rendered by a view.
      $view = $entity->view;
      //The current row we are on holds the date information for repeated events.
      $result = $view->result[$view->row_index];
      $field = 'field_data_field_date_field_date_value';
      $delta = -1;

      // Sometimes the result will hold the delta directly, we can use that if we have it.
      if (isset($result->field_data_field_date_delta)) {
        $delta = $result->field_data_field_date_delta;
      }
      else {
        // Use the date in the result field to get the delta on the repeated field_date field.
        foreach ($entity->field_date[LANGUAGE_NONE] as $d => $r) {
          if ($r['value'] == $result->$field) {
            $delta = $d;
            break;
          }
        }
      }
      $entity->date_id = 'node.'.$entity->nid.'.field_date.'.$delta;
    }
    else {
      if (isset($_GET['delta'])) {
        // The repeat number is set in the query string.
        $entity->date_id = 'node.' . $entity->nid . '.field_date.' . $_GET['delta'];
      }
      else {
        // This is a single node, and we need to filter it down to just the next occurence of an event.
        if (count($vars['items']) > 1) {
          foreach ($vars['items'] as $d => $i) {
            if (REQUEST_TIME < strtotime($i['value'])) {
              $entity->date_id = 'node.' . $entity->nid . '.field_date.' . $d;
              break;
            }
          }
        }
      }
    }
  }
}

/**
 * Implements hook_process_node().
 */
function os_events_process_node(&$variables) {
  if ($variables['type'] != 'event') {
    return;
  }

  // Move the terms to the top of the node display.
  if(isset($variables['content']['og_vocabulary'])) {
    $variables['content']['og_vocabulary']['#weight'] = 0;
  }
  // Move the event date above the event description.
  if(isset($variables['content']['field_date'])) {
    $variables['content']['field_date']['#weight'] = 0;
    // Append <p></p> tags for spacing.
    if(isset($variables['content']['field_date'][0]['#markup'])) {
      $variables['content']['field_date'][0]['#markup'] .= '<p></p>';
    }
  }

  $variables['link_title_text'] = '';
  $date = '';
  $delta = FALSE;
  if (isset($variables['date_id'])) {
    list(,,$field,$delta) = explode('.', is_array($variables['date_id']) ? reset($variables['date_id']) : $variables['date_id']);
    $delta = intval($delta);
    $date = field_get_items('node', $variables['node'], $field);
    $date = $date[$delta]['value'];
    $variables['link_title_text'] = t('On @date', array('@date' => date('D M j', strtotime($date.' UTC'))));
    if (isset($variables['content']['links']['node']['#links']['node-readmore'])) {
      $variables['content']['links']['node']['#links']['node-readmore']['attributes']['title'] .= ' on '.date('D M j', strtotime($date.' UTC'));
    }
  }

  $register = '';
  if ($variables['page'] && empty($variables['sv_list'])) {

    $registrations_type = !empty($variables['node']->field_event_registration[LANGUAGE_NONE][0]['registration_type']);

    // Show the signup link if capacity isn't reached.
    if ($registrations_type && os_events_event_registration_reach_capacity($variables['node'], $date)) {
      // In full view mode show a link to a modal.
      if ($variables['view_mode'] == 'full' && os_events_register_show_register_link($variables['node'], $date)) {
        $register = os_events_generate_modal_register_link($variables['node']->nid, $delta, array());
      } elseif ($variables['view_mode'] == 'full' && !os_events_register_show_register_link($variables['node'], $date)) {
        $result = os_events_registration_repeating_entity_settings('node', $variables['node']->nid, $date);
        $register = REQUEST_TIME >= strtotime($result['open']) ? '<span class="register-event-full">' . t('Registration Closed') . '</span>' : '';
      }
      // In teaser view mode link to the event page.
      elseif ($variables['view_mode'] == 'teaser') {
        $options = array();
        if ($delta !== FALSE) {
          $options = array('query' => array('delta' => $delta));
        }
        $register = '<div class="register-link-teaser">' . l(t('Registration is required'), 'node/' . $variables['node']->nid, $options) . '</div>';
      }
    }
    elseif ($registrations_type && $variables['view_mode'] == 'full' ) {
      $event_start_date = $variables['node']->field_date[LANGUAGE_NONE][0]['value'];
      // If the event is a past event
      if(!empty($event_start_date) && REQUEST_TIME > strtotime($event_start_date)) {
        $register = '<span class="register-event-full">' . t('Registration Closed') . '</span>';
      } else {
        $register = '<span class="register-event-full">' . t('Sorry, the event is full') . '</span>';
      }
    }

    // Change the date markup if this is a recurring event.
    if ($variables['content']['field_date']['#items'][0]['rrule']) {
      $variables['content']['field_date'][0]['#markup'] = _os_events_style_recurring_event($variables['content']['field_date'][0]['#markup']);
    }

    $options = array('absolute' => TRUE, 'attributes' => array('class' => array('subscribe')));
    $subscribe = l(t('subscribe'), 'calendar/single/'  . $variables['node']->nid . '/export.ics', $options);
    $subscribe = str_replace('http://', 'webcal://', $subscribe);

    // Hiding the original registration link because we are using our own link
    // with a ctools modal effect and because we placing the registration link
    // in the export area.
    hide($variables['content']['field_event_registration']);

    $ical = l(t('iCal'), 'calendar/single/' . $variables['node']->nid . '/export.ics', array('attributes' => array('class' => array('ical'))));

    $params = array(
      'register' => $register,
      'ical' => $ical,
      'subscribe' => $subscribe,
    );
    // Do not display event export links as per cp/settings page checkbox option.
    if (!variable_get('os_exporter_disable_event_export', 0)) {
      $variables['content']['export'] = array(
        '#markup' => theme('os_events_export_links', $params),
        '#weight' => 10,
      );
    }    
  }

  // In case of a "teaser" view mode, put the link before the date.
  if ($variables['view_mode'] == 'teaser') {
    $registrations_type = !empty($variables['node']->field_event_registration[LANGUAGE_NONE][0]['registration_type']);
    // If the event is allowed for signup and allowed to show to the users.
    $show_register_link = os_events_register_show_register_link($variables['node'], $date);
    if ($registrations_type && $show_register_link) {
      // Checking if the event has not reached its max registration limit.
      if (os_events_event_registration_reach_capacity($variables['node'], $date)) {
        $register = '<div class="register-link-teaser">' . t('Registration is required') . '</div>';
      } else {
        $register = '<span class="register-event-full">' . t('Sorry, the event is full') . '</span>';
      }
    } elseif ($registrations_type && !$show_register_link) {
        $event_start_date = $variables['node']->field_date[LANGUAGE_NONE][0]['value'];
        // If the event is a past event        
        if (!empty($event_start_date) && REQUEST_TIME > strtotime($event_start_date)) {
          $register = '<span class="register-event-full">' . t('Registration Closed') . '</span>';
        } elseif (os_events_event_registration_reach_capacity($variables['node'], $date)) {
          // Checking if the event has not reached its max registration limit.
          $register = '<span class="register-event-full">' . t('Registration Closed') . '</span>';
        } else {
          $register = '<span class="register-event-full">' . t('Sorry, the event is full') . '</span>';
        }
    }
    $variables['content']['field_date'][0]['#markup'] = $register . $variables['content']['field_date'][0]['#markup'];
  }

  // Hide the repeat rule summary from sidebar_teaser.
  if ($variables['view_mode'] == 'sidebar_teaser' && $variables['content']['field_date']['#items']) {
    $rule = theme_date_repeat_display(array(
      'item' => array('rrule' => $variables['content']['field_date']['#items'][0]['rrule']),
      'field' => field_info_field('field_date'),
    ));
    $variables['content']['field_date'][0]['#markup'] = str_replace($rule, '', $variables['content']['field_date'][0]['#markup'] );
  }
}

/**
 * Helper function; Changes the order or the repeat rule and dates for repeated
 * events.
 *
 * @param $markup
 *  The default markup that needs reordering.
 *
 * @return string
 *  The altered date markup..
 */
function _os_events_style_recurring_event($markup) {

  // Get the repeat rule section.
  $pattern = '/<div class="date-repeat-rule">[\s\S]*<\/div>/';
  if (preg_match($pattern, $markup, $matches)) {
    $repeat_rule = $matches[0];

    // Remove it from the markup.
    $markup = str_replace($repeat_rule, '', $markup);

    // Clear the period in the repeat rule.
    $repeat_rule = str_replace('.', '', $repeat_rule);

    // Rebuild the markup.
    $markup = $markup . $repeat_rule;
  }
  // Or, get the date section
  // relies on the regex being greedy
  $pattern = '/<span class="date-display-single">[\s\S]*<\/span>/';
  if (preg_match($pattern, $markup, $matches)) {
    $date = $matches[0];

    $markup = str_replace($date, '', $markup);

    $markup = $date . $markup;
  }

  $markup = preg_replace('/\s+\./', '.', $markup);
  return $markup;
}

/**
 * Generate the link for revealing the modal registration form.
 *
 * @param $nid
 *  The event NID.
 * @param $modal_settings
 *  Ctools modal settings.
 * @parm $sv_list
 *  TRUE if this is included in a sv_list
 *
 * @return string
 *  Link for the revealing the modal.
 */
function os_events_generate_modal_register_link($nid, $delta = FALSE, $modal_settings = array(), $sv_list = FALSE) {
  $modal_settings += array(
    'modalSize' => array(
      'type' => 'fixed',
      'width' => 700,
      'height' => 500,
      'addWidth' => 10,
      'addHeight' => 10,
      'contentRight' => 0,
      'contentBottom' => 0,
    ),
  );

  ctools_include('ajax');
  ctools_include('modal');
  ctools_modal_add_js();
  $modal_style = array(
    'events-modal-style' => $modal_settings,
  );
  drupal_add_js($modal_style, 'setting');

  $path = 'os_events/nojs/registration/' . $nid;
  if ($delta !== FALSE) {
    $path = $path . '/' . $delta;

    // Display all date options if this node is not in a sv_list
    if (!$sv_list) {
      static $options_cache;

      if(!isset($options_cache[$nid])) {
        $wrapper = entity_metadata_wrapper('node', $nid);
        $options_cache[$nid] = array();

        foreach ($wrapper->field_date as $d => $field_date) {
          $date = $field_date->value();
          if($d == $delta) continue;
          // Repetitive events 'choose another date' dropdown options should have only future dates.
          if (REQUEST_TIME >= strtotime($date['value'].' UTC')) continue;
          $options_cache[$nid][url($_GET['q'],array('query' => array('delta' => $d)))] = date('l, F j, Y', strtotime($date['value'].' UTC'));
        }
      }

      $options = $options_cache[$nid];
    }

    //Only allow switching if there is more than one option.
    if ($options) {
      $settings = array(
        'choose' => '-Select a different occurance-',
      );
      $form_state = array();
      ctools_include('jump-menu');
      $form = ctools_jump_menu(array(), $form_state, $options, $settings);
      $form['#attached']['js'][] = drupal_get_path('module', 'os') . '/theme/os_toggle.js';

      $date_switch  = l('(another date?)', $_GET['q'], array('attributes' => array('class' => array('os_event-moredates-link', 'toggle'))));
      $slider['abstract_slider'] = array(
        '#type' => 'container',
        '#weight' => 3,
        '#attributes' => array(
          'class' => array(
            'os_event-moredates-display',
            'os-slider',
          ),
        ),
        'abstract' => array(
          '#markup' => drupal_render($form)
        ),
      );
      $slider = drupal_render($slider);
    }
  }

  // Adding Mollom's js since ctools modal don't add the js.
  drupal_add_js(drupal_get_path('module', 'mollom') . '/mollom.js');

  $sign_up = ctools_ajax_text_button(t('Sign up for this event'), $path, '', 'ctools-use-modal ctools-modal-events-modal-style register use-ajax');

  return isset($date_switch)? $sign_up . $date_switch . $slider : $sign_up;
}

/**
 * Menu callback; Display the registration form in modal window.
 *
 * @param $js
 *  Ctools JS settings.
 * @param $node
 *  The node object.
 */
function os_events_events_register($js, $node, $date_id = FALSE) {
  ctools_include('modal');
  ctools_include('ajax');
  $repeating = $node->field_date['und'][0]['rrule'];
  // Repeating delta not present.
  if($repeating && $date_id === FALSE && !$js) {
    return;
  }

  $registration_type = registration_get_entity_registration_type('node', $node);
  $registration = entity_get_controller('registration')->create(array(
    'entity_type' => 'node',
    'entity_id' => $node->nid,
    'type' => $registration_type,
    'repeat_date' => $date_id,
  ));

  $registration->ajax = $js;
  $registration_form = drupal_get_form('registration_form', $registration);

  // Hide the OG audience field.
  $registration_form[OG_AUDIENCE_FIELD]['#access'] = FALSE;

  $date = '';
  if ($date_id !== FALSE) {
    $date = $registration_form['field_repeating_event_date']['und'][0]['value']['#default_value'];
  }

  if (!$js) {
    return $registration_form;
  }

  if (!os_events_event_registration_reach_capacity($node, $date) || ($repeating && $date_id === FALSE)) {

    if($repeating && $date_id == FALSE) {
      drupal_set_message(t('Unable to register for this repeating event, bad link detected.'), 'error');
    }

    if (!os_events_event_registration_reach_capacity($node, $date)) {
      drupal_set_message(t('The event has reached his maximum capacity of registrations. Sorry.'), 'error');
    }
    $commands = array();

    // dismiss the window
    $commands[] = ctools_modal_command_display(t('Error'), theme('status_messages'));

    print ajax_render($commands);
    drupal_exit();
    return;
  }

  $form_state = array(
    'title' => os_events_register_form_title('node', $node->nid),
    'ajax' => $js,
    'use_ctools' => TRUE,
  );

  $output = ctools_modal_form_render($form_state, $registration_form);
  print ajax_render($output);
  drupal_exit();
}

/**
 * Extra Validation for registration submission
 *
 * @param array $form
 * @param array $form_state
 */
function os_events_modal_validate($form, &$form_state) {

  if (empty($form_state['values']['anon_mail'])) {
    return;
  }

  $date = '';
  if (!empty($form_state['values']['field_repeating_event_date']['und'][0]['value'])) {
    $date = $form_state['values']['field_repeating_event_date']['und'][0]['value'];
  }
  $email_query = new EntityFieldQuery();
  $email_query->entityCondition('entity_type', 'registration')->propertyCondition('anon_mail', $form_state['values']['anon_mail']);

  if (isset($form['#entity']->registration_id)) {
    $email_query->propertyCondition('registration_id', $form['#entity']->registration_id, '<>');
  }

  if ($date) {
    $email_query->fieldCondition('field_repeating_event_date', 'value', $date);
  } //Flter to just this occurance

  if(count($email_query->execute())) {
    form_set_error('anon_mail', t('You have already registered and may not register again.'));
    return;
  }

  if ($user = user_load_by_mail($form_state['values']['anon_mail'])) {
    $user_query = new EntityFieldQuery();
    $user_query->entityCondition('entity_type', 'registration')->propertyCondition('user_uid', $user->uid);

    if ($date) {
      $user_query->fieldCondition('field_repeating_event_date', 'value', $date);
    }

    if(count($email_query->execute())) {
      form_set_error('anon_mail', t('You have already registered and may not register again.'));
      return;
    }
  }
}

/**
 * Submit handler; Dismissing the ctools modal window and display a message
 * when the registration is completed.
 */
function os_events_modal_submit($form, &$form_state) {
  if (!$form_state['registration']->ajax) {
    // The AJAX is disabled. Don't invoke the ajax_render command.
    return;
  }

  $commands = array();

  // dismiss the window
  $commands[] = ctools_modal_command_dismiss();
  // Display messages.
  $commands[] = ajax_command_before('#header', theme('status_messages'));

  // In case event is full update the register links via ajax.
  $event = node_load($form_state['registration']->entity_id);
 
  // Obtaining menu router item of the Ajax URL.
  $menu_item = menu_get_item();

  // If delta argument is present in URL, then query option will be available in url parameter otherwise no delta parameter will be available in email link.
  if ($menu_item['path'] == "os_events/%/registration/%" && isset($menu_item['original_map'][4]) && !empty($menu_item['original_map'][4])) {
    $query = array('delta' => $menu_item['original_map'][4]);
  } else {
    $query = array();
  }

  // Checking if this event is repeating event.
  $date = '';
  if (isset($menu_item['original_map'][4])) {
    $date = $event->field_date[LANGUAGE_NONE][$menu_item['original_map'][4]]['value'];
  }

  if (!os_events_event_registration_reach_capacity($event, $date)) {
    $selectors = array(
      '#node-' . $event->nid . ' .field-name-field-event-registration',
      '.os_events_export_links .first',
      '.register-link-teaser',
    );

    foreach ($selectors as $selector) {
      $commands[] = ajax_command_html($selector, '<span class="register-event-full">' . t('Sorry, the event is full') . '</span>');
    }

    // Triggering email to event author if the registration quota is full.
    $event_author = user_load($event->uid);
    $from = variable_get('site_mail', ini_get('sendmail_from'));
    $language = language_default();
    $params = array(
      '@url' => url('node/' . $event->nid, array('absolute' => TRUE, 'query' => $query)),
      '@title' => $event->title,
      '@user-name' => isset($event_author->field_first_name[LANGUAGE_NONE][0]['value']) ? $event_author->field_first_name[LANGUAGE_NONE][0]['value'] : $event_author->name,
      '@site' => variable_get('site_name', 'OpenScholar')
    );
    drupal_mail('os_events', 'registration_full_notification', $event_author->mail, $language, $params, $from);    
  }

  // Clean any message.
  drupal_get_messages();

  print ajax_render($commands);
  drupal_exit();
}

/**
 * Calendar datebox preprocess.
 *
 * RE-build the links to use query strings, instead of "clean urls".
 */
function os_events_preprocess_calendar_datebox(&$vars) {
  $date = $vars['date'];
  $view = $vars['view'];
  $vars['day'] = intval(substr($date, 8, 2));
  $day_path = calendar_granularity_path($view, 'day');

  $options = array(
    'query' => array(
      'type' => 'day',
      'day' => $vars['date'],
    ),
    'absolute' => TRUE,
  );

  $vars['link'] = !empty($day_path) ? l($vars['day'], 'calendar', $options) : $vars['day'];
}

/**
 * Implements hook_views_pre_view().
 */
function os_events_views_pre_view(&$view, &$display_id, &$args) {
  if ($view->name != 'os_events') {
    return;
  }

  if (!in_array($display_id, array('block_2', 'block_1'))) {
    $buttons = array(
      'subscribe' => 'calendar/upcoming/all/export.ics',
      'iCal' => 'calendar/upcoming/all/export.ics',
      'rss' => 'calendar/upcoming/all/rss.xml'
    );

    foreach ($buttons as $label => $path) {
      // When the user is filtering events by taxonomy term we need to add the
      // path to the iCal/rss export path.
      $term_path = os_taxonomy_in_taxonomy_term_context($view);
      if ($term_path) {
        // Get the current taxonomy term path from the $_GET['q'] and remove the
        // word calendar for prevent duplication of the word.
        $path_parts = explode("/", $term_path);
        $tid = array_pop($path_parts);
        $path = str_replace("upcoming/all/", "term/$tid/", $path);
      }

      $links[$label] = array(
        'title' => t($label),
        'href' => $path,
        'attributes' => array('class' => array(strtolower($label))),
      );
    }

    // Make sure webcal link uses webcal protocol.
    $links['subscribe']['href'] = str_replace('http://', 'webcal://', url($links['subscribe']['href'], array('absolute' => TRUE)));

    $view->attachment_before .= theme('links', array(
      'links' => $links,
      "attributes" => array('class' => array('links', 'inline')),
    ));

    // For /calendar pages, for month, weeks and days view where export links are available.
    if (strpos($display_id, 'page') === 0) {
      $export_result = views_get_view_result('os_events', 'feed_1');
      // Checking if there are no rows in views result for export as ical or rss
      if (count($export_result) == 0) {
        $warning_msg = array();
        $warning_msg[] = t('No events are available for export');
        $view->attachment_before = theme('item_list', array('items' => $warning_msg, 'attributes' => array('class' => 'links no-event-export')));
      }
    }  
  }

  if (empty($view->display_handler->display->display_options['pager']['options']['date_id'])) {
    // Not a calendar view, or a mini-calendar
    return;
  }

  // Add JS for event popup.
  drupal_add_js(drupal_get_path('module', 'os_events') . '/js/os_events_popup.js');
  drupal_add_library('system', 'ui.dialog');

  $handler = &$view->display_handler;

  // Adding the JS for side by side events display for the week view mode.
  if (isset($_GET['type']) && $_GET['type'] == 'week') {
    drupal_add_js(drupal_get_path('module', 'os_events') . '/js/os_events.js');
  }

  if (!empty($view->display_handler->display->display_options['style_options']['mini'])) {
    // Set the default date of the mini calendar to the date the user watching.
    $format = array('year' => 'Y', 'month' => 'Y-m', 'week' => 'Y-\W', 'day' => 'Y-m-d');

    if (isset($_GET['type']) && $_GET['type'] == 'year') {
      // The user watch a year, return him the current time.
      $time = time();
    }
    else {
        if (isset($_GET['type']) && isset($_GET[$_GET['type']])) {
          $time = strtotime($_GET[$_GET['type']]);
        } else {
          $time = time();
        }
    }

    $view->args[0] = date($format['month'], $time);
    return;
  }

  if (empty($_GET['type']) || !in_array($_GET['type'], array('day', 'week', 'month', 'year'))) {
    return;
  }

  if ($_GET['type'] != 'month') {
    $handler->set_option('style_plugin', 'calendar_style');
  }

  $values = $handler->get_option('style_options');
  $values['calendar_type'] = $_GET['type'];
  $values['groupby_times'] = 'hour';
  $handler->set_option('style_options', $values);

  $values = $handler->get_option('pager');
  $values['options']['date_id'] = $_GET['type'];
  $handler->set_option('pager', $values);


  $values = $handler->get_option('arguments');
  $values['date_argument']['granularity'] = $_GET['type'];
  $handler->set_option('arguments', $values);
}

/**
 * Implements hook_preprocess_date_views_pager().
 *
 * Dealing with different context of the calendar view modes.
 */
function os_events_preprocess_date_views_pager(&$variables) {
  if ($variables['plugin']->options['date_id'] == 'mini') {
    return;
  }

  // Define some variables.
  $plugin = $variables['plugin'];
  $view = $plugin->view;
  $date_info = $view->date_info;
  $next_url = &$variables['next_url'];
  $prev_url = &$variables['prev_url'];
  $granularity = !empty($date_info->calendar_type) ? $date_info->calendar_type : 'month';
  $format = array('year' => 'Y', 'month' => 'Y-m', 'week' => 'Y-\W', 'day' => 'Y-m-d');

  // Get information about dates.
  $min_date = $date_info->min_date;

  $prev_date = clone $min_date;
  $next_date = clone $min_date;

  $prev_date->modify('-1 ' . $granularity);
  $next_date->modify('+1 ' . $granularity);

  switch ($granularity) {
    case 'week':
      $next_week = date_week(date_format($next_date, 'Y-m-d'));
      $prev_week = date_week(date_format($prev_date, 'Y-m-d'));
      $next_arg = date_format($next_date, $format[$granularity]) . date_pad($next_week);
      $prev_arg = date_format($prev_date, $format[$granularity]) . date_pad($prev_week);
      break;
    default:
      $next_arg = date_format($next_date, $format[$granularity]);
      $prev_arg = date_format($prev_date, $format[$granularity]);
  }

  // Change the link URL and arguments.
  $variables['next_options']['query'] = array($granularity => $next_arg, 'type' => $granularity);
  $variables['prev_options']['query'] = array($granularity => $prev_arg, 'type' => $granularity);
  $next_url = $_GET['q'];
  $prev_url = $_GET['q'];
}

/**
 * Implements hook_views_query_alter().
 *
 * Setting a default value to the $_GET['month'] or $_GET['type'] if not exists.
 *
 * When filtering by terms there could be a case when the type or the month are
 * not defined in the $_GET variables.
 */
function os_events_views_query_alter($view, views_plugin_query_default $query) {
  if ($view->name != 'os_events' ) {
    return;
  }

  // is this a view a feed view?
  if ($view->current_display == 'feed_1' || $view->current_display == 'feed_2') {
    // Alter the exported events according the current path.
    $menu = menu_get_item();

    // narrow down export to single event
    if ($menu['map'][1] == "single" && is_numeric($menu['map'][2])) {
      unset($query->where[1]['conditions'][4]);
      $query->add_where($query->options['group'], "node.nid", $menu['map'][2], "=");
    }
    else {
      // filter by the current taxonomy term filtering.
      if ($menu['map'][1] == 'term' && is_numeric($menu['map'][2])) {
        $alias = $query->add_table('field_data_og_vocabulary');
        $query->set_distinct();
        $query->add_where($query->options['group'], "$alias.og_vocabulary_target_id", $menu['map'][2], '=');
      }
    }
  }
  else {
    $format = array('year' => 'Y', 'month' => 'Y-m', 'week' => 'Y-\W', 'day' => 'Y-m-d');

    // Determine the type of the displayed month by the argument from the address
    $_GET['type'] = isset($_GET['type']) ? $_GET['type'] : 'month';

    // Determine the value of the calendar view mode(day, year, month) argument value
    $_GET[$_GET['type']] = isset($_GET[$_GET['type']]) ? $_GET[$_GET['type']] : date($format[$_GET['type']], time());
  }
}

/**
 * Implements hook_url_outbound_alter().
 *
 * Change the url of the prev and next links.
 */
function os_events_url_outbound_alter(&$path, &$options, $original_path) {

  // Overriding View/Edit/Delete links in Event sign up registration listing.
  if (preg_match('|^registration/([0-9]*)(/.*)?|', $path, $matches)) {
    if (isset($matches[2]) && in_array($matches[2], array('/edit', '/delete'))) {
      $options['query'] = array_merge(drupal_get_query_parameters(), drupal_get_destination());
    } else {
      $options['query'] = drupal_get_query_parameters();
    }
  }

  $view_modes = array(
    'calendar/day',
    'calendar/year',
  );

  if (!in_array($original_path, $view_modes) && strpos($path, 'calendar/month/') === FALSE) {
    return;
  }

  $mini_calendar = strpos($path, 'calendar/month/') !== FALSE;
  $data = explode('/', $original_path);
  $path = $data[0];

  $format = array('year' => 'Y', 'month' => 'Y-m', 'day' => 'Y-m-d');
  $date_format = new DateTime;

  if (isset($_GET[$data[1]])) {
    if ($_GET['type'] == 'year') {
      // The user watch in a year, return him to the first day of the year.
      $time = mktime(12, 0, 0, 1, 1, $_GET[$data[1]]);
    }
    else {
      $time = strtotime($_GET[$data[1]]);
    }
    $date_format->setTimestamp($time);
  }

  $date = date_format($date_format, $format[$data[1]]);

  $type = $data[1];

  if ($mini_calendar) {
    $type = 'month';
    $date = $data[2];
  }

  $options['query'] = array(
    'type' => $type,
    $data[1] => $date,
  );
}

/**
 * Implements hook_preprocess_menu_local_task().
 *
 * Remove the active from any tab in the calendar page and add active to the
 * correct tab.
 */
function os_events_preprocess_menu_local_task(&$variables) {
  if ($_GET['q'] != 'calendar' || !isset($_GET['type'])) {
    return;
  }
  $element = &$variables['element'];
  $element['#active'] = FALSE;

  $cases = array(
    'day' => 'calendar/day',
    'week' => 'calendar/week',
    'year' => 'calendar/year',
    'month' => 'calendar/month',
  );

  if (isset($cases[$_GET['type']]) && $cases[$_GET['type']] == $element['#link']['path']) {
    $element['#active'] = TRUE;
  }
}

/**
 * Implements hook_preprocess_link().
 *
 * Remove the active from any link in the calendar page and add active class to
 * the correct link.
 */
function os_events_preprocess_link(&$variables) {
  if ($_GET['q'] != 'calendar') {
    return;
  }

  if ($variables['path'] == 'calendar' && $variables['text'] == t('Month')) {
    // The user watch different view modes of the calendar, remove the active
    // from the the month link.
    if (!in_array($_GET, array('day', 'week', 'year')) && !empty($_GET['type'])) {
      $key = array_search('active', $variables['options']['attributes']['class']);
      unset($variables['options']['attributes']['class'][$key]);
    }
  }

  $view_modes = array(
    'calendar/week',
    'calendar/day',
    'calendar/year',
  );

  if (empty($_GET['type']) || !in_array($variables['path'], $view_modes)) {
    return;
  }

  $cases = array(
    'day' => 'calendar/day',
    'week' => 'calendar/week',
    'year' => 'calendar/year',
    'month' => 'calendar/month',
  );

  if (isset($cases[$_GET['type']]) && $cases[$_GET['type']] == $variables['path']) {
    $variables['options']['attributes']['class'][] = 'active';
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function os_events_form_registration_entity_settings_form_alter(&$form, $form_state) {
  $wrapper = entity_metadata_wrapper('node', $form_state['entity']['entity_id']);
  // Hide the tokens list for sending messages to registrants.
  unset($form['token_tree']);

  $repeating_event_date = FALSE;
  if (isset($form_state['build_info']['args'][0]['repeating_event_date'])) {
    $repeating_event_date = $form_state['build_info']['args'][0]['repeating_event_date'];
  }

  // Default value of the From field should be the author of the event's e-mail
  // in case it hasn't been changed yet (if it hasn't been changed yet, the email
  // will be set by default to be as defined in the field instance).
  $info = field_info_instance('node', 'field_event_registration', 'event');
  $default_email = $info['settings']['default_registration_settings']['settings']['from_address'];
  if ($form['settings']['from_address']['#default_value'] == $default_email) {
    $from_default_value = $wrapper->author->mail->value();
  }
  else {
    $from_default_value = $form['settings']['from_address']['#default_value'];
  }

  $form['status']['#title'] = t('Enable registrations');
  $form['status']['#description'] = t('Users must register their attendance in advance.');

  $open_date = $form['scheduling']['open']['#default_value'];
  $close_date = $form['scheduling']['close']['#default_value'];
  $reminder_date = $form['reminder']['reminder_settings']['reminder_date']['#default_value'];
  $reminder_on = $form['reminder']['reminder_settings']['reminder_status']['#default_value'];

  $format = 'M d Y h:i A';
  // Replace textual date fields in favor of date popup.
  $form['scheduling']['open'] = array(
    '#type' => 'date_popup',
    '#title' => t('Open date'),
    '#description' => t('When to automatically open registrations'),
    '#default_value' => empty($open_date) ? date('Y-m-d H:i') : date('Y-m-d H:i', strtotime($open_date)),
    '#date_format' => $format,
  );

  $form['scheduling']['close'] = array(
    '#type' => 'date_popup',
    '#title' => t('Close date'),
    '#description' => t('When to automatically close registrations.'),
    '#default_value' => empty($close_date) ? '' : date('Y-m-d H:i', strtotime($close_date)),
    '#date_format' => $format,
  );

  // Add 'from' field.
  $form['from'] = array(
    '#type' =>'textfield',
    '#title' => t('From'),
    '#required' => TRUE,
    '#description' => t('Email address to be displayed as the message\'s sender.'),
    '#default_value' => $from_default_value,
    '#element_validate' => array('os_events_validate_mail'),
  );

  // Set the default time for a reminder to be a day before the event.
  $event_date = $wrapper->field_date->get(0)->value();
  $reminder = empty($reminder_date) ? strtotime('-1 day', strtotime($repeating_event_date?$repeating_event_date:$event_date['value'])) : strtotime($reminder_date);
  $form['reminder']['reminder_settings']['reminder_date'] = array(
    '#type' => 'date_popup',
    '#title' => t('Reminder Date'),
    '#description' => t('When to send reminders.'),
    '#default_value' => $reminder && !empty($reminder_date) ? date('Y-m-d H:i', strtotime($reminder_date)) : date('Y-m-d H:i'),
    '#date_format' => $format,
    '#states' => array(
      'visible' => array(
        ':input[name="reminder[send_reminder]"]' => array('checked' => TRUE),
      ),
    ),
  );

  // Remove the template, reminder date is no longer inside a container.
  $delta = empty($_GET['delta']) ? 0 : $_GET['delta'];
  $form['reminder']['reminder_settings']['reminder_template'] = $form['reminder']['reminder_settings']['reminder_template'] + array(
    '#access' => FALSE,
    '#value'  => $reminder_on ? variable_get('os_reminder_template', "
Hello,

This is only a friendly reminder that you registered the event <a href='[node:url]?delta={$delta}'>[node:title]</a>.") : '',
  );
  $form['reminder']['reminder_settings']['token_tree']['#access'] = FALSE;
  $form['reminder']['reminder_settings']['#type'] = 'container';
  $form['reminder']['#type'] = 'container';


  // Default to no repeating event date.
  $form['field_repeating_event_date'] = array(
    '#type' => 'value',
    '#value' => $repeating_event_date,
  );

  if ($repeating_event_date) {
    $defaults  = l('(change defaults)', $_GET['q'], array('attributes' => array('class' => array('os_event-default-settings-link'))));

    $form['field_repeating_event_date_text'] = array(
      '#type' => 'item',
      '#markup' => '<span class="date-display-single">'. t('Changing settings for @date', array('@date' => date('l, F j, Y', strtotime($repeating_event_date.' UTC'))))."</span>".$defaults,
      '#weight' => -10,
    );
  } elseif ($repeating_event_date === '' && count($wrapper->field_date) > 1) {
    // Changing for all instances.
    $form['field_repeating_event_date_text'] = array(
      '#type' => 'item',
      '#markup' => '<span class="date-display-single">'. t('You are changing the default settings for all occurances of this event.')."</span>",
      '#weight' => -10,
    );

    foreach ($wrapper->field_date as $delta => $field_date) {
      $date = $field_date->value();
      $options[url($_GET['q'],array('query' => array('delta' => $delta)))] = date('l, F j, Y', strtotime($date['value'].' UTC'));
    }
    $settings = array(
      'choose' => t('-- Go to a specific date instead --'),
    );
    if (isset($options)) {
      ctools_include('jump-menu');
      $form =  $form + ctools_jump_menu($form, $form_state, $options, $settings);
      $form['jump']['#weight'] = $form['go']['#weight'] = -9;
    }
  }

  $form['settings']['#access'] = FALSE;

  $form['reminder']['#weight'] = 9;
  $form['scheduling']['#weight'] = 10;
  $form['save']['#weight'] = 11;

  // Add handler to populate the "from_address" field in the form with the value
  // submitted in the "from" field. This is done since the registration module
  // needs the email value to be in the "settings" element which is given a
  // "#access = FALSE".
  $form['#validate'][0] = 'os_registration_entity_settings_form_validate';
  $form['#validate'][] = '_os_events_update_from_address';
  $form['#validate'][] = 'os_events_validate_end_date_after_start';
  $default_submit = array_search('registration_entity_settings_form_submit',$form['#submit']);
  $form['#submit'][$default_submit] = 'os_events_registration_entity_settings_form_submit';
  $form['#submit'][] = 'os_events_invalidate_cache';

  $form['#attached']['js'][] = drupal_get_path('module', 'os_events') . '/js/os_events.js';

  $form['#after_build'][] = 'os_events_registration_entity_after_build';
}

/**
 * Custom Submit handler for registration_entity_settings_form().
 *
 * @array $form
 * @array $form_state
 */
function os_registration_entity_settings_form_validate($form, &$form_state) {
  // Ensure capacity is a non-negative integer.
  $capacity = $form_state['values']['capacity'];
  if (!is_numeric($capacity) || ((int) $capacity != $capacity) || ($capacity < 0)) {
    form_set_error('capacity', t('"Capacity" must be a positive integer or 0 for unlimited.'));
  }

  // Ensure slot limit is a non-negative integer.
  $slot_limit = $form_state['values']['settings']['maximum_spaces'];
  if (!is_numeric($slot_limit) || ((int) $slot_limit != $slot_limit) || ($slot_limit < 0)) {
    form_set_error('maximum_spaces', t('"Spaces allowed" must be a positive integer or 0 for unlimited.'));
  }

  // Validate from address:
  if (!valid_email_address($form_state['values']['settings']['from_address'])) {
    form_set_error('settings][from_address', t('From email address is invalid.'));
  }

  // Validate open date:
  if (!empty($form_state['values']['scheduling']['open']) && is_string($form_state['values']['scheduling']['open']) && strtotime($form_state['values']['scheduling']['open']) === FALSE) {
    form_set_error('scheduling][open', t('Date is invalid.'));
  }

  // Validate close date:
  if (!empty($form_state['values']['scheduling']['close']) && is_string($form_state['values']['scheduling']['close']) && strtotime($form_state['values']['scheduling']['close']) === FALSE) {
    form_set_error('scheduling][close', t('Date is invalid.'));
  }

  // If sending a reminder, ensure date and template are set.
  $reminder = $form_state['values']['reminder'];
  if ($reminder['send_reminder'] && (empty($reminder['reminder_settings']['reminder_date']) || empty($reminder['reminder_settings']['reminder_template']))) {
    form_set_error('reminder][send_reminder', t('If sending a reminder, provide a date and template.'));
  }

  // If reminder date or template are set, ensure we're sending a reminder.
  if (empty($reminder['send_reminder'])) {
    if (!empty($reminder['reminder_settings']['reminder_template'])) {
      form_set_error('reminder][reminder_settings][reminder_template', t('You have provided a reminder template, but not opted to send a reminder. Either check the box to send a reminder, or do not provide a reminder template.'));
    }
  }

  // Validate reminder date:
  if (!empty($reminder['reminder_settings']['reminder_date'])
    && strtotime($reminder['reminder_settings']['reminder_date']) === FALSE
  ) {
    form_set_error('reminder][reminder_settings][reminder_date', t('Reminder date is invalid.'));
  }

  // Ensure reminder date is not in the past when "send_reminder" is TRUE:
  if ($reminder['send_reminder'] && !empty($reminder['reminder_settings']['reminder_date'])) {
    if (strtotime($reminder['reminder_settings']['reminder_date']) <= time()) {
      form_set_error('reminder][reminder_settings][reminder_date', t('Reminder must be in the future.'));
    }
  }
}

/**
 * After build; Change the order the validation handlers.
 */
function os_events_registration_entity_after_build($form, $form_state) {
  array_unshift($form['#validate'], 'os_events_validate_handle_reminder');
  return $form;
}

/**
 * Validate handler; Take care with bad values from the reminder part.
 */
function os_events_validate_handle_reminder($form, &$form_state) {
  // Since we are hiding the reminder template from the form the and the user
  // switch from not reminding to reminding the original validation handler
  // messed up.
  $delta = empty($_GET['delta']) ? 0 : $_GET['delta'];
  $reminder = &$form_state['values']['reminder'];
  $reminder['reminder_settings']['reminder_template'] = $form_state['values']['reminder']['send_reminder'] ? variable_get('os_reminder_template', "
Hello,

This is only a friendly reminder that you registered the event <a href='[node:url]?delta={$delta}'>[node:title]</a>.") : '';
}

/**
 * Validate handler; Verifying the end date set to be after the start date.
 */
function os_events_validate_end_date_after_start($form, $form_state) {
  if (empty($form_state['values']['scheduling']['close'])) {
    return;
  }

  $scheduling = $form_state['values']['scheduling'];

  $start = strtotime($scheduling['open']);
  $end = strtotime($scheduling['close']);

  if ($start > $end) {
    form_set_error('scheduling][close', t('The End date must be greater than the Start date'));
  }
}

/**
 * Implements hook_token_info_alter().
 */
function os_events_token_info_alter(&$data) {
  // Adding token for the registration entity.
  $data['tokens']['registration']['attendee_name'] = array(
    'name' => t("The attendee name"),
    'description' => t("The name of the attendee according to the name field."),
  );
}

/**
 * Implements hook_tokens().
 */
function os_events_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();

  // Only handling registration.
  if ($type != 'registration') {
    return;
  }

  $wrapper = entity_metadata_wrapper('registration', $data['registration']);

  $replacements['[registration:attendee_name]'] = $wrapper->field_full_name->value() ? ' ' . $wrapper->field_full_name->value() : '';

  return $replacements;
}

/**
 * Helper function; Populates the settings of the registration with the "from"
 * email address.
 */
function _os_events_update_from_address(&$form, &$form_state) {
  $form_state['values']['settings']['from_address'] = $form_state['values']['from'];
}

/**
 * Element validate; Validate the email of the user.
 */
function os_events_validate_mail($element, $form_state, $form) {
  if (!valid_email_address($element['#value'])) {
    form_error($element, t('This is not a valid email address.'));
  }
}

/**
 * Implements hook_field_widget_WIDGET_TYPE_form_alter().
 */
function os_events_field_widget_registration_select_form_alter(&$element, &$form_state, $context) {
  $element['registration_type']['#type'] = 'checkbox';

  // Set the "return value" to our default signup.
  $element['registration_type']['#return_value'] = 'event_signup_simple';

  $items = $context['items'];
  $element['registration_type']['#default_value'] = !empty($items[0]['registration_type']);

  // Remove the options, so they won't fail our validation.
  unset($element['registration_type']['#options']);

  $element['registration_type']['#title'] = t('Signup');
  $element['registration_type']['#description'] = t('If checked, users will be able to signup for this event.');

  // Add JS to change button description,
  $element['registration_type']['#attached']['js'] = array(
    drupal_get_path('module', 'os_events') . '/js/os_events_signup_description.js'
  );
}

/**
 * Implements hook_menu_alter().
 */
function os_events_menu_alter(&$items) {
  $items['node/%entity_object/register']['access callback'] = FALSE;
  $items['admin/structure/registration/registration_states']['access callback'] = FALSE;

  //Use custom settings callback
  $items['node/%entity_object/registrations/settings']['page callback'] = 'os_events_entity_settings_page';
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function os_events_form_registration_registrations_broadcast_form_alter(&$form, $form_state) {
  // Hide the tokens list for sending messages to registrants.
  unset($form['token_tree']);

  // Extend the length of the "subject" field.
  $form['subject']['#maxlength'] = 150;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function os_events_form_registration_form_alter(&$form, &$form_state) {

  $registration = $form_state['registration'];
  if(isset($registration->repeat_date) && $registration->entity_type == 'node') {
    $node = node_load($registration->entity_id);

    $delta = intval($registration->repeat_date);
    $date = field_get_items('node', $node, 'field_date');
    if (isset($date[$delta])) {
      // Set the date for the registration.
      $form_state['registration']->field_repeating_event_date['und'][0]['value'] = $date[$delta]['value'];
      // Use custom registration settings.
      $settings_overrides = os_events_registration_repeating_entity_settings($registration->entity_id, $registration->entity_type, $date[$delta]['value']);
      if ($settings_overrides) {
        $form['#registration_settings'] = $settings_overrides;
      }

      //Set the default in the form
      $form['field_repeating_event_date']['und'][0]['value']['#default_value'] = $date[$delta]['value'];
      $form['field_repeating_event_date']['#access'] = FALSE;

      $form['field_repeating_event_date_text'] = array(
        '#type' => 'item',
        '#markup' => '<span class="date-display-single">'. t('On @date', array('@date' => date('l, F j, Y', strtotime($date[$delta]['value'].' UTC'))))."</span>",
        '#weight' => -10,
      );

    }
  } elseif (isset($form['field_repeating_event_date'])) {
    $form['field_repeating_event_date']['#access'] = FALSE;
    $form['og_group_ref']['#access'] = FALSE;
  }

  $form['who_is_registering'] = array(
    '#type' => 'value',
    '#value' => 'registration_registrant_type_anon',
  );

  //Don't show the state dropdown
  $form['state']['#access'] = FALSE;

  if (isset($form['#entity']->registration_id)) {
    $form['actions']['cancel'] = array(
      '#type' => 'submit',
      '#value' => t('Cancel'),
      '#submit' => array('cancel_button_destination_callback'),
      '#limit_validation_errors' => array(),
    );
  } else {
    $form['actions']['cancel']['#access'] = FALSE;
  }

  $form['actions']['submit']['#value'] = isset($form['#entity']->registration_id) ? t('Save') : t('Signup');

  $form['anon_mail']['#required'] = TRUE;

  $form['event_register'] = array(
    '#type' => 'container',
    '#title' => t('Sign up for this event'),

    'field_full_name' => $form['field_full_name'],
    'field_department' => $form['field_department'],
    'anon_mail' => $form['anon_mail'],
    'actions' => $form['actions'],
  );

  // Make sure the form it rebuilt, so if there's a validation error, we can
  // keep the event registration fieldset open.
  $form_state['rebuild'] = TRUE;
  unset($form['actions'], $form['field_full_name'], $form['field_department'], $form['anon_mail'], $form['user']);

  $form['#validate'][] = 'registration_form_validate';
  $form['#validate'][] = 'os_events_modal_validate';
  $form['#submit'][] = 'os_events_modal_submit';
}

/**
 * When clicking on cancel button in event registration edit page.
 */
function cancel_button_destination_callback($form, &$form_state) {
  $destination = drupal_get_destination();
  drupal_goto($destination);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function os_events_form_registration_delete_confirm_alter(&$form, &$form_state) {
  drupal_set_title(t('Are you sure you want to delete registration for !name (@email)?', array('!name' => $form['registration']['#value']->field_full_name[LANGUAGE_NONE][0]['value'], '@email' => $form['registration']['#value']->anon_mail)));
}

/**
 * When changing the settings of the a registration invalidate the cache.
 */
function os_events_invalidate_cache($form, $form_state) {
  os_boxes_invalidate_cache($form_state['entity']['entity_id'], 'node');
}

/**
 * Implements hook_preprocess_table().
 */
function os_events_preprocess_table(&$variables) {
  $menu = menu_get_item();

  if ($menu['path'] != 'node/%/registrations') {
    return;
  }

  $event = $menu['page_arguments'][1];
  $repeating = $event->field_date['und'][0]['rrule'];
  if ($repeating && isset($_GET['delta'])) {
    $delta = intval($_GET['delta']);
    $d = field_get_items('node', $event, 'field_date');
    $date = $d[$delta]['value'];
  }


  // Change the title of the registrations table.
  $variables['caption'] = t('List of registrations for %multiple %title.', array(
    '%multiple' => ($repeating)? (isset($date)?date('l, F j, Y', strtotime($date.' UTC'))." of":"all occurances of"):"",
    '%title' => entity_label('node', $menu['map'][1]),
  ));

  if ($repeating && !isset($date)) {

    $date = field_get_items('node', $event, 'field_date');

    $form_state = array();
    foreach ($date as $delta => $field_date) {
      $options[url($_GET['q'],array('query' => array('delta' => $delta)))] = date('l, F j, Y', strtotime($field_date['value'].' UTC'));
    }
    $settings = array(
      'choose' => t('-- Go to a specific date instead --'),
    );
    if(isset($options)) {
      ctools_include('jump-menu');
      $form = ctools_jump_menu($form, $form_state, $options, $settings);
      $variables['caption'] .= drupal_render($form);
    }
  }

  // Remove the "id", "user", "count" and the "states" from the table head.
  unset($variables['header'][0], $variables['header'][2], $variables['header'][4], $variables['header'][6]);

  // Remove the "id", "user", "count" and the "states" from each table row.
  foreach (array_keys($variables['rows']) as $delta) {
    unset($variables['rows'][$delta][0], $variables['rows'][$delta][2], $variables['rows'][$delta][4], $variables['rows'][$delta][6]);
  }
}

/**
 * Implements hook_entity_query_alter().
 */
function os_events_entity_query_alter($query) {

  // Skip this if we are not looking for registrations.
  if (empty($query->entityConditions) || $query->entityConditions['entity_type']['value'] != 'registration') {
    return;
  }

  $menu = menu_get_item();
  $event = NULL;
  if ($menu['path'] == 'node/%/registrations' && is_object($menu['page_arguments'][1])) {
    $event = $menu['page_arguments'][1];
  }

  if ($menu['path'] == 'node/%/registrations/broadcast' && is_object($menu['page_arguments'][2])) {
    $event = $menu['page_arguments'][2];
  }

  if (!$event) {
    return;
  }

  $repeating = $event->field_date['und'][0]['rrule'];

  // Is this the registration list EFQ.
  if (!$repeating) {
    return;
  }

  if (!isset($_GET['delta'])) {
    return;
  }

  $delta = intval($_GET['delta']);
  $date = field_get_items('node', $event, 'field_date');
  $date = $date[$delta]['value'];
  $query->fieldCondition('field_repeating_event_date', 'value', $date);
}

/**
 * Implements hook_preprocess_page().
 *
 * Add a dropdown menu for the registration page.
 */
function os_events_preprocess_page(&$variables) {
  $menu = menu_get_item();
  if (strpos($menu['path'], 'node/%/registrations') !== 0) {
    return;
  }

  if (empty($variables['tabs']['#secondary'])) {
    return;
  }

  // Remove the "Simple view" tab from the navigation tabs.
  foreach ($variables['tabs']['#secondary'] as $index => $tab) {
    if ($tab['#link']['title'] == 'Simple view') {
      unset($variables['tabs']['#secondary'][$index]);
      break;
    }
  }

  // If there are no registrants, do not display the download link.
  if (empty($menu['original_map'][1])) {
    return;
  }

  $event_id = $menu['original_map'][1];
  $node = node_load($event_id);
  $delta = isset($_GET['delta']) ? $_GET['delta'] : FALSE;
  $repeating = $node->field_date['und'][0]['rrule'];
  $date = '';
  if ($repeating && $delta !== FALSE) {
    $date = $node->field_date['und'][$delta]['value'];
  }

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'registration')
      ->propertyCondition('entity_id', $event_id)
      ->propertyCondition('entity_type', 'node');

  // Filter to just this occurrence.
  if ($date) {
    $query->fieldCondition('field_repeating_event_date', 'value', $date);
  }

  $result = $query->execute();

  if (empty($result['registration'])) {
    return;
  }

  // Create drop-down links for simple view and export of registrants.
  $event = node_load($event_id);
  $registration_links = array(
    'export' => array(
      'title' => t('CSV'),
      'href' => 'node/' . $event_id . '/registrations/export' . (($date)? '/' . $delta : ''),
    ),
    'simple_view' => array(
      'title' => t('Simple view'),
      'href' => 'node/' . $event_id . '/registrations/simple_view' . (($date)? '/' . $date : ''),
    ),
  );
  $variables['tabs']['#secondary']['registration_links'] = array(
    '#theme' => 'ctools_dropdown',
    '#links' => $registration_links,
    '#title' => t('Download Registrant List'),
    '#class' => 'section_links registration_links',
    '#access' => registration_administer_registrations_access('node', $event),
  );
}

/**
 * Implements hook_mollom_form_list().
 */
function os_events_mollom_form_list() {
  $forms = array();
  $forms['registration_form'] = array(
    'title' => t('Registration form'),
    'entity' => 'registration',
    'bundle' => 'event_signup_simple',
  );
  return $forms;
}

/**
 * Implements hook_mollom_form_info().
 */
function os_events_mollom_form_info($form_id) {
  $form_info = array(
    'bundle' => 'event_signup_simple',
    'elements' => array(),
    'mapping' => array(
      'author_email' => 'anon_email',
    ),
  );

  mollom_form_info_add_fields($form_info, 'registration', 'event_signup_simple');

  return $form_info;
}

/**
 * Save the settings for the mollom form.
 */
function os_events_save_mollom_settings() {
  $mollom_form = array(
    'form_id' => 'registration_form',
    'mode' => '1',
    'checks' => array('spam'),
    'enabled_fields' => array(
      'field_department][und][0][value',
      'field_full_name][und][0][value',
    ),
    'strictness' => 'normal',
    'discard' => '1',
    'moderation' => 0,
    'entity' => 'registration',
    'bundle' => 'event_signup_simple',
    'module' => 'os_events',
    'title' => 'Registration form',
    'elements' => array(
      'field_department][und][0][value' => 'Department',
      'field_full_name][und][0][value' => 'Full Name',
    ),
    'mapping' => array(
      'author_email' => 'anon_email',
      'post_id' => 'registration_id',
    ),
    'bypass access' => array(),
    'mail ids' => array(),
  );

  mollom_form_save($mollom_form);
}

/**
 * Implements hook_modules_enabled().
 *
 * When enabling the mollom module we need to add the event registration form
 * to mollom form protection list.
 */
function os_events_modules_enabled($modules) {
  if (!in_array('mollom', $modules)) {
    return;
  }

  os_events_save_mollom_settings();
}

/**
 * Implements hook_date_ical_feed_event_render_alter().
 */
function os_events_date_ical_feed_event_render_alter(&$event, $view, &$context) {
  $wrapper = entity_metadata_wrapper('node', $context['entity']);
  $event['description'] = '';
  $event['summary'] = $wrapper->label();
  if ($value = $wrapper->body->value()) {
    $event['description'] = drupal_html_to_text($value['value']);;
  }

  $event['location'] = $wrapper->field_event_location->value();
}

/**
 * Implements hook_entity_insert().
 *
 * Sending notification for user when subscribing to event.
 */
function os_events_entity_insert($entity, $type) {
  if ($type != 'registration') {
    return;
  }
  $wrapper = entity_metadata_Wrapper($type, $entity);
  $node = node_load($entity->entity_id);

  // Get author mail id
  $event_author = user_load($node->uid);

  // Obtaining menu router item of the Ajax URL.
  $menu_item = menu_get_item();

  // If delta argument is present in URL, then query option will be available in url parameter otherwise no delta parameter will be available in email link.
  if ($menu_item['path'] == "os_events/%/registration/%" && isset($menu_item['original_map'][4]) && !empty($menu_item['original_map'][4])) {
     $query = array('delta' => $menu_item['original_map'][4]);
     $delta = $menu_item['original_map'][4];
  } else {
    $query = array();
    $delta = 0;
  }

  // Determine if the event is a All Day event
  $start = date('Y-m-d H:i:s', strtotime($node->field_date['und'][$delta]['value'].' UTC'));
  $end = date('Y-m-d H:i:s', strtotime($node->field_date['und'][$delta]['value2'].' UTC'));
  $all_day = date_is_all_day($start, $end);

  // Showing time value in case of not All Day event
  if ($all_day) {
    $date = date('l, F j, Y', strtotime($node->field_date['und'][$delta]['value'].' UTC'));
  } else {
    $date = date('l, F j, Y g:ia', strtotime($node->field_date['und'][$delta]['value'].' UTC'));
  }

  $module = 'os_events';
  $key = 'registration_confirmation';
  $language = language_default();
  $params = array(
    '@url' => url('node/' . $node->nid, array('absolute' => TRUE, 'query' => $query)),
    '@title' => $node->title,
    '@user-name' => $wrapper->field_full_name->value(),
    '@event_date_time' => $date,
    '@event_location' => $node->field_event_location['und'][0]['value'],
    '@event_creator_email' => $event_author->mail,
  );

  // Pass the entity type and ID to give modules implementing
  // hook_mail_alter() more context.
  $params['context'] = array(
    'entity_type' => 'node',
    'entity_id' => $node->nid,
  );

  // Get the event's author to set the "from" email address. If it hasn't been
  // set yet in the registration settings, use the event's author email address.
  $registration_settings = registration_entity_settings('node', $node->nid);
  $info = field_info_instance('node', 'field_event_registration', 'event');
  $default_email = $info['settings']['default_registration_settings']['settings']['from_address'];
  if ($registration_settings['settings']['from_address'] == $default_email) {
    $event_author = user_load($node->uid);
    $from = $event_author->mail;
  }
  else {
    $from = $registration_settings['settings']['from_address'];
  }

  // Displaying confirmation message to user's screen.
  drupal_set_message(t('You have successfully registered for the event. Please check your email for confirmation.'));

  drupal_mail($module, $key, $wrapper->anon_mail->value(), $language, $params, $from);
}

/**
 * Implements hook_mail().
 */
function os_events_mail($key, &$message, $params) {
  switch ($key) {
    case 'registration_broadcast':
    case 'registration_confirmation':
        $message['subject'] = t("@title event registration confirmation", $params);
        $message['body'] = array();
        $message['body'][0] = t("Hello @user-name", $params);
        $message['body'][1] = t("You have been registered for @title", $params);
        if (!empty($params['@event_date_time'])) {
          $message['body'][1].= t(" on @event_date_time", $params);
        }
        if (!empty($params['@event_location'])) {
          $message['body'][1].= t(" at @event_location", $params);
        }
        $message['body'][1].= ".";
        $message['body'][2] = t("View the event listing here: @url", $params);
        $message['body'][3] = t("Questions? Email the event organizer @event_creator_email", $params);
        $message['body'][4] = t("See you there!", $params);
        break;

    case 'registration_full_notification':
        $message['subject'] = t("@title event registration is full", $params);
        $message['body'] = array();
        $message['body'][] = t("Hi @user-name", $params);
        $message['body'][] = t("This email is to let you know that the event you created, @title, is now full.\nYou can manage your registrations here: @url.\n\nThe @site Team", $params);
        break;  
  }
}

/**
 * Implements hook_mail_alter().
 */
function os_events_mail_alter(&$message) {
  if (!in_array($message['id'], array('registration_broadcast', 'os_events_registration_confirmation'))) {
    return;
  }

  // Get event default email address.
  $wrapper = entity_metadata_wrapper($message['params']['context']['entity_type'], $message['params']['context']['entity_id']);
  $event_author_email = $wrapper->author->mail->value();

  // Default value of the "From" field should be the author of the event's e-mail
  // in case it hasn't been changed yet (if it hasn't been changed yet, the email
  // will be set by default to be as defined in the field instance).
  $info = field_info_instance('node', 'field_event_registration', 'event');
  $default_email = $info['settings']['default_registration_settings']['settings']['from_address'];
  if ($message['headers']['From'] == $default_email) {
    $message['headers']['From'] = $message['from'] = $event_author_email;
  }

  // Set the sender and return-path headers.
  $message['headers']['Sender'] = $message['headers']['Return-Path'] = $message['headers']['From'];
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Include JS to update the End Date field according to the Start Date field on
 * event node form.
 */
function os_events_form_event_node_form_alter(&$form, &$form_state) {
  $form['#attached']['js'][] = drupal_get_path('module', 'os_events') . '/js/os_events.js';
  $form['#validate'][] = 'os_events_validate_repeat_on_checkbox';
}

/**
 * Validate handler; Verifying if at least one day/month checkbox is selected for 'Repeat on' section in Weekly/Monthly/Yearly repeating event form.
 */
function os_events_validate_repeat_on_checkbox($form, $form_state) {
  // Obtaining repeat rules from form submission.
  $repeating = $form_state['values']['field_date'][LANGUAGE_NONE][0]['rrule'];

  // For non-repeating events, $repeating will be NULL.
  if ($repeating) {
    // Formatting repeat rules in structured array.
    $parts = date_repeat_split_rrule($repeating);
    $rrule = $parts[0];
    // Validation for weekly, monthly and yearly repeating events.
    if (!isset($rrule['BYDAY']) && $rrule['FREQ'] == 'WEEKLY') {
      form_set_error('field_date][' . LANGUAGE_NONE . '][0][rrule][FREQ', t('You must select at least one day.'));
    } elseif (!isset($rrule['BYMONTH']) && $rrule['FREQ'] == 'MONTHLY') {
        form_set_error('field_date][' . LANGUAGE_NONE . '][0][rrule][FREQ', t('You must select at least one month.'));
    } elseif (!isset($rrule['BYMONTH']) && $rrule['FREQ'] == 'YEARLY') {
        // Validation for two types of radio button choice for monthly and yearly repeating events.
        // e.g On day <NUM> of <MONTH> / On the <FIRST> <SUNDAY> of <MONTH>.
        if (!isset($rrule['BYMONTHDAY'])) {
          form_set_error('field_date][' . LANGUAGE_NONE . '][0][rrule][FREQ', t('Repeats On the field must have at least one month option checked.'));
        } else {
          form_set_error('field_date][' . LANGUAGE_NONE . '][0][rrule][FREQ', t('You must select at least one month.'));
        }
    }
  }
}

/**
 * Determine if the user can register to the event.
 *
 * @param $node
 *   The node object.
 *
 * @return bool
 */
function os_events_register_show_register_link($node, $date = '') {
  if ($node->type != 'event') {
    return;
  }

  $result = os_events_registration_repeating_entity_settings('node', $node->nid, $date);

  if (empty($result)) {
    return FALSE;
  }

  if (!$result['status']) {
    return FALSE;
  }
  
  // If there is no closing date given, checking if current date is greater than the opening date or not.
  if (isset($result['open']) && REQUEST_TIME >= strtotime($result['open']) && !$result['close']) {
    return os_events_show_register_by_node($node, $date);
  }

  // Checking if the event date is in future or not. else signup link will not be shown.
  if (isset($node->field_date[LANGUAGE_NONE][0]['value']) && REQUEST_TIME > strtotime($node->field_date[LANGUAGE_NONE][0]['value'])) {
    // Checking repeating event date and non-repeating event dates.
    if (isset($result['repeating_event_date']) && REQUEST_TIME > strtotime($result['repeating_event_date'] . ' UTC')) {
      return FALSE;
    } elseif (isset($result['repeating_event_date']) && $result['repeating_event_date'] == '') {
      return FALSE;
    }
  }

  if (!empty($result['close'])) {
    return REQUEST_TIME >= strtotime($result['open']) && REQUEST_TIME <= strtotime($result['close']);
  }
  
  return REQUEST_TIME >= strtotime($result['open']);
}

/**
 * In case the event registration don't have open or close range, the fallback
 * will be to check the registration availability by the date field.
 *
 * @param $node
 *   The event node.
 *
 * @return bool
 */
function os_events_show_register_by_node($node, $date = FALSE) {

  if (!$date) {
    $wrapper = entity_metadata_wrapper('node', $node);

    if ($wrapper->getBundle() != 'event') {
      return;
    }

    $value = $wrapper->field_date->get(0)->value();
    $date = $value['value'];
  }

  $date = new DateTime($date, new DateTimeZone('UTC'));
  // We only need to verify the event didn't started yet.
  return time() <= $date->getTimestamp();
}

/**
 * Implements hook_theme_registry_alter().
 */
function os_events_theme_registry_alter(&$theme_registry) {
  $theme_registry['registration_link']['function'] = 'os_events_registration_link';
}

/**
 * Changing the theme callback for the registration link theme.
 */
function os_events_registration_link($variables) {

  if (!empty($variables['entity'])) {
    $node = $variables['entity'];
    if (isset($node->date_id)) {
      list(,,$field,$delta) = explode('.', $node->date_id);
    }
  } else {
    list(,$nid,) = explode('/', $variables['path']);
    $node = node_load($nid);
  }

  if (!isset($delta)) {
    $delta = isset($_GET['delta']) ? $_GET['delta'] : FALSE;
  }

  $repeating = $node->field_date['und'][0]['rrule'];
  $date = '';
  if ($repeating && $delta) {
    $date = $node->field_date['und'][$delta]['value'];
  }

  if (!os_events_event_registration_reach_capacity($node, $date)) {
    return '<span class="register-event-full">' . t('Sorry, the event is full') . '</span>';
  }

  if (!os_events_register_show_register_link($node, $date)) {
    return;
  }

  return os_events_generate_modal_register_link($node->nid, $delta, array(), !empty($node->sv_list));
}

/**
 * Alter the local tasks to include the delta.
 */
function os_events_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  $alter_urls = array('node/%','node/%/registrations','node/%/registrations/settings','node/%/registrations/broadcast','node/%/registrations/list');
  // Add action link to 'node/add' on 'admin/content' page.
  if (in_array($root_path,$alter_urls) && $router_item['map'][1]->type == 'event' && (isset($router_item['map'][1]->date_id) || isset($_GET['delta']))) {
    //Get the Delta
    if (isset($router_item['map'][1]->date_id)) {
      list(,,$field,$delta) = explode('.', $router_item['map'][1]->date_id);
    } else {
      $delta = $_GET['delta'];
    }

    //Loop through the primary tabs.
    foreach ($data['tabs'] as $index => $tabs) {
      foreach ($tabs['output'] as $n => $tab) {
        if (in_array($tab['#link']['path'],$alter_urls)) {
          $data['tabs'][$index]['output'][$n]['#link']['localized_options']['query'] = array('delta' => $delta);
        }
      }
    }
  }
}

/**
 * Page callback for repeating events registration settings.
 *
 * @param $entity_type
 * @param $entity
 *
 * @return array
 *   Registration entity settings form.
 */
function os_events_entity_settings_page($entity_type, $entity) {

  list($entity_id) = entity_extract_ids($entity_type, $entity);
  $repeating = $entity->field_date['und'][0]['rrule'];

  $date = '';
  if ($repeating && isset($_GET['delta'])) {
    $delta = intval($_GET['delta']);
    $date = field_get_items('node', $entity, 'field_date');
    $date = $date[$delta]['value'];
  } else if($repeating) {
    $date = '';
  }

  $settings = os_events_registration_repeating_entity_settings($entity_type, $entity_id, $date);

  if (!$repeating) {
    unset($settings['repeating_event_date']);
  }
  return drupal_get_form('registration_entity_settings_form', $settings, $entity_type, $entity_id);
}

/**
 * Get registration settings for a repeating event.
 *
 * @param string $entity_type
 *   The host entity type.
 * @param int $entity_id
 *   The host entity ID.
 *
 * @return array|bool
 *   A row from {registration_entity}, or FALSE if no settings exist.
 */
function os_events_registration_repeating_entity_settings($entity_type, $entity_id, $date_string, $reset = FALSE) {
  $result = &drupal_static(__FUNCTION__ . $entity_type . $entity_id . $date_string);

  if (!$result || $reset) {
    $result = db_select('registration_entity', 're')
      ->fields('re')
      ->condition('entity_id', $entity_id, '=')
      ->condition('entity_type', $entity_type, '=')
      ->condition('repeating_event_date', array($date_string,''), 'IN')
      ->orderBy('repeating_event_date', 'DESC') //Get custom settings first
      ->range(0,1)
      ->execute()
      ->fetchAssoc();

    if ($result) {
      $result['settings'] = unserialize($result['settings']);
      $result['repeating_event_date'] = $date_string;
    }
  }

  return $result;
}

/**
 * Submit handler for registration_entity_settings_form().
 *
 * @param array $form
 * @param array $form_state
 */
function os_events_registration_entity_settings_form_submit($form, &$form_state) {
  $entity = $form_state['entity'];

  $fields = registration_convert_form_settings($form_state['values']);

  if (empty($form_state['values']['field_repeating_event_date'])) {
    $form_state['values']['field_repeating_event_date'] = '';
  }

  db_merge('registration_entity')
    ->key(array(
    'entity_id' => $entity['entity_id'],
    'entity_type' => $entity['entity_type'],
    'repeating_event_date' => $form_state['values']['field_repeating_event_date'],
  ))
    ->fields($fields)
    ->execute();

  drupal_set_message(t('Registration settings have been saved.'));

  $uri = entity_uri($entity['entity_type'], entity_load_single($entity['entity_type'], $entity['entity_id']));

  $query = array();
  if (!empty($form_state['values']['field_repeating_event_date'])) {
    $query['delta'] = $_GET['delta'];
  }

  $form_state['redirect'] = array($uri['path'],array('query' => $query));
}

/**
 * Update the registration status to acomidate sharing one node for multiple dates
 *
 * $status 0 / 1
 * $context = array(
 *  'entity_type' => $entity_type,
 *  'entity_id' => $entity_id,
 *  'errors' => &$errors
 * );
 */
function os_events_registration_status_alter(&$status, &$context) {

  $menu = menu_get_item();
  if ($menu['path'] != 'os_events/%/registration/%' || !isset($menu['page_arguments'][2])) {
    return;
  }

  $wrapper = entity_metadata_wrapper($context['entity_type'], $context['entity_id']);
  $event_date = $wrapper->field_date->get($menu['page_arguments'][2])->value();
  if (!$event_date) {
    return;
  }

  $settings = os_events_registration_repeating_entity_settings($context['entity_type'], $context['entity_id'], $event_date['value'], TRUE);
  $status = $settings['status'];
  if (!$status) {
    //Nothing more to do.
    return;
  }

  $errors = array();
  $open = isset($settings['open']) ? strtotime($settings['open']) : NULL;
  $close = isset($settings['close']) ? strtotime($settings['close']) : NULL;
  $capacity = $settings['capacity'];
  $now = REQUEST_TIME;

  // check max allowed spaces per registration
  if ((isset($settings['settings']['maximum_spaces']) && $settings['settings']['maximum_spaces']) && $spaces > $settings['settings']['maximum_spaces']) {
    $status = FALSE;
    $errors[] = t('You may not register for more than @count spaces.', array('@count' => $settings['settings']['maximum_spaces']));
  }
  // check capacity

  if ($capacity) {
    $count = registration_event_count($entity_type, $entity_id, $registration_id, $reset) + $spaces;
    if (($capacity - $count) < 0) {
      $status = FALSE;
      $errors[] = t('Insufficient spaces remaining.');
    }
  }

  // check open date range
  if (isset($open) && ($now < $open)) {
    $status = FALSE;
    $errors[] = t('Registration is not yet open.');
  }
  // check close date range
  if (isset($close) && ($now >= $close)) {
    $status = FALSE;
    $errors[] = t('Registration is closed.');
  }
}

/**
 * Implements hook_entity_property_info_alter().
 */
function os_events_entity_property_info_alter(&$info) {
  $info['node']['bundles']['event']['properties']['field_event_registration'] = array(
    'type' => 'unknown',
    'setter callback' => 'entity_metadata_field_verbatim_set',
    'getter callback' => 'entity_metadata_field_verbatim_get',
    'label' => t('Registration'),
  );
}

/**
 * Implements hook_preprocess_calendar_item().
 */
function os_events_preprocess_calendar_item(&$vars) {
  $item = $vars['item'];
  if (in_array($item->granularity, array('day', 'week'))) {
    $item->item_height = os_events_get_event_duration($item);
  }

  // Prepare popover fields.
  if (in_array($item->granularity, array('day', 'week', 'month'))) {
    $item->popover_fields['event_title'] = $item->rendered_fields['title'];
    $item->popover_fields['event_delta'] = $item->rendered_fields['delta'];

    // @TODO: Is this format OK?
    $item->popover_fields['event_date'] = $item->rendered_fields['field_date'];
    $item->popover_fields['event_location'] = $item->rendered_fields['field_event_location'];
  }
}

/**
 * Get the duration of an event in hours.
 *
 * @param $item
 *   The event item.
 * @return mixed
 *   The event duration in hours or NULL if end time equals start time.
 */
function os_events_get_event_duration($item) {
  $event_start = strtotime($item->calendar_start);
  $event_end = strtotime($item->calendar_end);

  if ($event_start == $event_end) {
    return NULL;
  }

  $hours = round(($event_end - $event_start) / 3600, 1);

  return 80 * $hours . 'px';
}

/**
 * Constructs a human-readable description of the repeat rule.
 * @param string $rrule
 * repeat rules string
 * @param string $format
 * date format for displaying the day, month and year.
 * @return string
 * human-readable description as output
 */
function os_date_repeat_rrule_description($rrule, $format = 'D M d Y') {
  // Empty or invalid value.
  if (empty($rrule) || !strstr($rrule, 'RRULE')) {
    return;
  }

  module_load_include('inc', 'date_api', 'date_api_ical');
  module_load_include('inc', 'date_repeat', 'date_repeat_calc');

  $parts = date_repeat_split_rrule($rrule);

  $additions = $parts[2];
  $exceptions = $parts[1];
  $rrule = $parts[0];
  if ($rrule['FREQ'] == 'NONE') {
    return;
  }

  // Make sure there will be an empty description for any unused parts.
  $description = array(
    '!interval' => '',
    '!byday' => '',
    '!bymonth' => '',
    '!count' => '',
    '!until' => '',
    '!except' => '',
    '!additional' => '',
    '!week_starts_on' => '',
    );
  $interval = date_repeat_interval_options();
  switch ($rrule['FREQ']) {
    case 'WEEKLY':
      $description['!interval'] = format_plural($rrule['INTERVAL'], 'every week', 'every @count weeks');
      $freq_type = 'weekly';
      break;
    case 'MONTHLY':
      $description['!interval'] = format_plural($rrule['INTERVAL'], 'every month', 'every @count months');
      $freq_type = 'monthly';
      break;
    case 'YEARLY':
      $description['!interval'] = format_plural($rrule['INTERVAL'], 'every year', 'every @count years');
      $freq_type = 'yearly';
      break;
    default:
      $description['!interval'] = format_plural($rrule['INTERVAL'], 'every day', 'every @count days');
      $freq_type = 'daily';
      break;
  }

  if (!empty($rrule['BYDAY'])) {
    $days = date_repeat_dow_day_options();
    $counts = date_repeat_dow_count_options();
    $days_results = array();
    $day_count = 0;
    foreach ($rrule['BYDAY'] as $byday) {
      // Get the numeric part of the BYDAY option, i.e. +3 from +3MO.
      $day = substr($byday, -2);
      $count = str_replace($day, '', $byday);
      $day_count++;

      if (!empty($count)) {
        // See if there is a 'pretty' option for this count, i.e. +1 => First.
        $order = array_key_exists($count, $counts) ? strtolower($counts[$count]) : $count;
        $days_results[] = trim(t(' on the !date_order !day_of_week', array('!date_order' => $order, '!day_of_week' => $days[$day])));
      }
      else {
        $days_results[] = trim(t('!day_of_week', array('!day_of_week' => $days[$day])));
      }
    }
  }

  if (!empty($rrule['BYMONTH'])) {
    if (sizeof($rrule['BYMONTH']) < 12) {
      $results = array();
      $months = date_month_names();
      foreach ($rrule['BYMONTH'] as $month) {
        $results[] = $months[$month];
      }
      if (!empty($rrule['BYMONTHDAY'])) {
        $description['!bymonth'] = trim(t(' on the !month_days of !month_names', array('!month_days' => implode(', ', $rrule['BYMONTHDAY']), '!month_names' => implode(', ', $results))));
      }
      else {
        $description['!bymonth'] = trim(t(' of !month_names', array('!month_names' => implode(', ', $results))));
      }
    }
  }

  if ($freq_type == 'daily') {
    // Omitting 'every day' string for daily events
    if (isset($days_results)) {
      $description['!interval'] = '';
      $description['!byday'] = t('every ') . implode(', ', $days_results);
    }
    // It will be displayed as every weekday
    if (isset($rrule['BYDAY']) && count($rrule['BYDAY']) == 5) {
      $description['!byday'] = 'every weekday';
    }
  } elseif ($freq_type == 'weekly') {
      if (isset($days_results) && count($days_results) > 1 && empty($rrule['COUNT'])) {
        $prefix_day_weekly = ' on ';
      } else {
        $prefix_day_weekly = count($days_results) > 0 ? ' every ' : '';
      }
    $description['!byday'] = t($prefix_day_weekly) . implode(', ', $days_results);
  } elseif ($freq_type == 'monthly') {
      if(isset($days_results)) {
        $description['!interval'] = '';
        $description['!byday'] = implode(', ', $days_results) . (!empty($description['!bymonth']) ? ' ' . $description['!bymonth'] : '' );
        $description['!bymonth'] = '';
      }
      $description['!interval'] .= (!empty($description['!bymonth']) ? ' ' : '' );
  } elseif ($freq_type == 'yearly') {
      if(isset($days_results)) {
        $description['!byday'] = implode(', ', $days_results) . (!empty($description['!bymonth']) ? ' ' . $description['!bymonth'] : '' );
        $description['!bymonth'] = '';
      }
      $description['!interval'] .= (!empty($description['!bymonth']) ? ' ' : '' );
  }
  if ($rrule['INTERVAL'] < 1) {
    $rrule['INTERVAL'] = 1;
  }
  if (!empty($rrule['COUNT'])) {
    $description['!count'] = trim(t(', !count times', array('!count' => $rrule['COUNT'])));
  }
  if (!empty($rrule['UNTIL'])) {
    $until = date_ical_date($rrule['UNTIL'], 'UTC');
    date_timezone_set($until, date_default_timezone_object());
    $description['!until'] = trim(t(' until !until_date', array('!until_date' => date_format_date($until, 'custom', $format))));
  }
  if ($exceptions) {
    $values = array();
    foreach ($exceptions as $exception) {
      $except = date_ical_date($exception, 'UTC');
      date_timezone_set($except, date_default_timezone_object());
      $values[] = date_format_date($except, 'custom', $format);
    }
    $description['!except'] = trim(t('!repeats_every_interval except !except_dates', array('!repeats_every_interval ' => '', '!except_dates' => implode(', ', $values))));
  }
  if (!empty($rrule['WKST'])) {
    $day_names = date_repeat_dow_day_options();
    $description['!week_starts_on'] = trim(t('!repeats_every_interval where the week start on !day_of_week', array('!repeats_every_interval ' => '', '!day_of_week' => $day_names[trim($rrule['WKST'])])));
  }
  if ($additions) {
    $values = array();
    foreach ($additions as $addition) {
      $add = date_ical_date($addition, 'UTC');
      date_timezone_set($add, date_default_timezone_object());
      $values[] = date_format_date($add, 'custom', $format);
    }
    $description['!additional'] = trim(t('Also includes !additional_dates.', array('!additional_dates' => implode(', ', $values))));
  }
  return t('Repeats !interval!bymonth!byday!count !until !except. !additional', $description);
}
